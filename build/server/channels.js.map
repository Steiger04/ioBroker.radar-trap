{
  "version": 3,
  "sources": ["../../src/server/channels.ts"],
  "sourcesContent": ["import \"@feathersjs/transport-commons\";\n\nimport type { HookContext } from \"@feathersjs/feathers\";\nimport type { Application } from \"./declarations\";\n\nexport default function (app: Application): void {\n\tif (typeof app.channel !== \"function\") {\n\t\t// If no real-time functionality has been configured just return\n\t\treturn;\n\t}\n\n\tapp.on(\"connection\", (connection: any): void => {\n\t\t// On a new real-time connection, add it to the anonymous channel\n\t\tapp.channel(\"anonymous\").join(connection);\n\t});\n\n\tapp.service(\"routes\").publish((data: any, context: HookContext) => {\n\t\tif (context.params.publishEvent === false) {\n\t\t\t// Console.log('channels -> context (=== false)', context.result);\n\t\t\treturn;\n\t\t}\n\n\t\t// Console.log('channels -> context (!== false)', context.result);\n\t\treturn app.channel(\"anonymous\");\n\t});\n\n\tapp.service(\"routes\").publish(\n\t\t\"status\",\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t(data: radarTrap.GenericStatusWithId, context: HookContext) =>\n\t\t\t// Console.log('channels -> status)', context.result);\n\t\t\tapp.channel(\"anonymous\"),\n\t);\n\n\tapp.service(\"areas\").publish((data: any, context: HookContext) => {\n\t\tif (context.params.publishEvent === false) {\n\t\t\t// Console.log('channels -> context (=== false)', context.result);\n\t\t\treturn;\n\t\t}\n\n\t\t// Console.log('channels -> context (!== false)', context.result);\n\t\treturn app.channel(\"anonymous\");\n\t});\n\n\tapp.service(\"areas\").publish(\n\t\t\"status\",\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t(data: radarTrap.GenericStatusWithId, context: HookContext) =>\n\t\t\t// Console.log('channels -> status)', context.result);\n\t\t\tapp.channel(\"anonymous\"),\n\t);\n\n\t// App.on('login', (authResult: any, { connection }: any): void => {\n\t//     // connection can be undefined if there is no\n\t//     // real-time connection, e.g. when logging in via REST\n\t//     if (connection) {\n\t//         // Obtain the logged in user from the connection\n\t//         // const user = connection.user;\n\t//\n\t//         // The connection is no longer anonymous, remove it\n\t//         app.channel('anonymous').leave(connection);\n\t//\n\t//         // Add it to the authenticated user channel\n\t//         app.channel('authenticated').join(connection);\n\t//\n\t//         // Channels can be named anything and joined on any condition\n\t//\n\t//         // E.g. to send real-time events only to admins use\n\t//         // if(user.isAdmin) { app.channel('admins').join(connection); }\n\t//\n\t//         // If the user has joined e.g. chat rooms\n\t//         // if(Array.isArray(user.rooms)) user.rooms.forEach(room => app.channel(`rooms/${room.id}`).join(connection));\n\t//\n\t//         // Easily organize users by email and userid for things like messaging\n\t//         // app.channel(`emails/${user.email}`).join(connection);\n\t//         // app.channel(`userIds/${user.id}`).join(connection);\n\t//     }\n\t// });\n\n\t// app.publish((data: any, hook: HookContext) => {\n\t//     // Here you can add event publishers to channels set up in `channels.ts`\n\t//     // To publish only for a specific event use `app.publish(eventname, () => {})`\n\t//\n\t//     console.log(\n\t//         'Publishing all events to all authenticated users. See `channels.ts` and https://docs.feathersjs.com/api/channels.html for more information.',\n\t//     ); // eslint-disable-line\n\t//\n\t//     // e.g. to publish all service events to all authenticated users use\n\t//     return app.channel('authenticated');\n\t// });\n\n\t// app.publish((data: any, hook: HookContext) => app.channel('anonymous'));\n\n\t// Here you can also add service specific event publishers\n\t// e.g. the publish the `users` service `created` event to the `admins` channel\n\t// app.service('users').publish('created', () => app.channel('admins'));\n\n\t// With the userid and email organization from above you can easily select involved users\n\t// app.service('messages').publish(() => {\n\t//   return [\n\t//     app.channel(`userIds/${data.createdBy}`),\n\t//     app.channel(`emails/${data.recipientEmail}`)\n\t//   ];\n\t// });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAO;AAKQ,SAAR,iBAAkB,KAAwB;AAChD,MAAI,OAAO,IAAI,YAAY,YAAY;AAEtC;AAAA,EACD;AAEA,MAAI,GAAG,cAAc,CAAC,eAA0B;AAE/C,QAAI,QAAQ,WAAW,EAAE,KAAK,UAAU;AAAA,EACzC,CAAC;AAED,MAAI,QAAQ,QAAQ,EAAE,QAAQ,CAAC,MAAW,YAAyB;AAClE,QAAI,QAAQ,OAAO,iBAAiB,OAAO;AAE1C;AAAA,IACD;AAGA,WAAO,IAAI,QAAQ,WAAW;AAAA,EAC/B,CAAC;AAED,MAAI,QAAQ,QAAQ,EAAE;AAAA,IACrB;AAAA,IAEA,CAAC,MAAqC,YAErC,IAAI,QAAQ,WAAW;AAAA,EACzB;AAEA,MAAI,QAAQ,OAAO,EAAE,QAAQ,CAAC,MAAW,YAAyB;AACjE,QAAI,QAAQ,OAAO,iBAAiB,OAAO;AAE1C;AAAA,IACD;AAGA,WAAO,IAAI,QAAQ,WAAW;AAAA,EAC/B,CAAC;AAED,MAAI,QAAQ,OAAO,EAAE;AAAA,IACpB;AAAA,IAEA,CAAC,MAAqC,YAErC,IAAI,QAAQ,WAAW;AAAA,EACzB;AAsDD;",
  "names": []
}
