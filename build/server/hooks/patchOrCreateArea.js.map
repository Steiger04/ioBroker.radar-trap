{
  "version": 3,
  "sources": ["../../../src/server/hooks/patchOrCreateArea.ts"],
  "sourcesContent": ["import area from \"@turf/area\";\nimport bbox from \"@turf/bbox\";\nimport bboxPolygon from \"@turf/bbox-polygon\";\nimport booleanContains from \"@turf/boolean-contains\";\nimport booleanOverlap from \"@turf/boolean-overlap\";\nimport {\n\tfeature,\n\tFeature,\n\tfeatureCollection,\n\tLineString,\n\tPoint,\n\tProperties,\n} from \"@turf/helpers\";\nimport pointsWithinPolygon from \"@turf/points-within-polygon\";\nimport square from \"@turf/square\";\nimport squareGrid from \"@turf/square-grid\";\nimport { determineTrapTypes } from \"../../lib/atudo/determineTrapTypes\";\nimport { traps } from \"../../lib/atudo/traps\";\nimport { Scheduler } from \"../../lib/Scheduler\";\n\nimport type { Hook, HookContext } from \"@feathersjs/feathers\";\nimport polyline from \"@mapbox/polyline\";\nimport { featureReduce } from \"@turf/meta\";\nimport transformScale from \"@turf/transform-scale\";\nimport console from \"console\";\n\nconst patchOrCreateArea = (): Hook => {\n\treturn async (context: HookContext<radarTrap.Area>) => {\n\t\tconst startTime = performance.now();\n\t\tconst { data, service, params } = context;\n\t\tconst { _id } = data!;\n\n\t\tScheduler.pause(_id);\n\t\tservice.emit(\"status\", { _id: data!._id, status: \"loading\" });\n\n\t\tconst [record] = (await service.find({\n\t\t\tquery: { _id },\n\t\t\tpaginate: false,\n\t\t})) as radarTrap.Areas;\n\n\t\t// console.log(\"record\", record);\n\n\t\tif (params.patchSourceFromClient || params.patchSourceFromServer) {\n\t\t\tconst areaPolygon = Object.values(data!.areaPolygons!)[0];\n\t\t\t// console.log(\"areaPolygon\", areaPolygon.geometry.coordinates);\n\n\t\t\tconst areaBox = bbox(areaPolygon);\n\t\t\t// console.log(\"areaBox\", areaBox);\n\n\t\t\tconst squareBox = square(areaBox);\n\t\t\t// console.log(\"squareBox\", squareBox);\n\n\t\t\tconst squareBoxPolygon = transformScale(\n\t\t\t\tbboxPolygon(squareBox),\n\t\t\t\t1.3,\n\t\t\t);\n\t\t\t// console.log(\"squareBoxPolygon\", squareBoxPolygon);\n\n\t\t\tconst sideLength = Math.sqrt(area(squareBoxPolygon)) / 1e3;\n\t\t\t// console.log(\"sideLength\", sideLength);\n\n\t\t\tlet sideLengthDivisor = 0;\n\n\t\t\tif (sideLength > 3000) {\n\t\t\t\tsideLengthDivisor = 80;\n\t\t\t} else if (sideLength > 1500) {\n\t\t\t\tsideLengthDivisor = 60;\n\t\t\t} else if (sideLength > 900) {\n\t\t\t\tsideLengthDivisor = 25;\n\t\t\t} else if (sideLength > 500) {\n\t\t\t\tsideLengthDivisor = 15;\n\t\t\t} else if (sideLength > 100) {\n\t\t\t\tsideLengthDivisor = 10;\n\t\t\t} else {\n\t\t\t\tsideLengthDivisor = 10;\n\t\t\t}\n\n\t\t\tconst squareBoxGrid = squareGrid(\n\t\t\t\tbbox(squareBoxPolygon),\n\t\t\t\tsideLength / sideLengthDivisor,\n\t\t\t);\n\t\t\t// console.log(\"squareBoxGrid\", squareBoxGrid.features.length);\n\n\t\t\tconst reducedSquareBoxGrid = featureCollection(\n\t\t\t\tsquareBoxGrid.features.filter((feature) => {\n\t\t\t\t\t// console.log(\"feature::\", feature.geometry!.coordinates);\n\t\t\t\t\treturn (\n\t\t\t\t\t\tbooleanOverlap(areaPolygon, feature) ||\n\t\t\t\t\t\tbooleanContains(areaPolygon, feature)\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t/* console.log(\n\t\t\t\t\"reducedSquareBoxGrid\",\n\t\t\t\treducedSquareBoxGrid.features.length,\n\t\t\t); */\n\n\t\t\tlet resultTraps:\n\t\t\t\t| Feature<Point>[]\n\t\t\t\t| Record<string, Feature<Point, Properties>[]> = [];\n\n\t\t\tlet resultPolyPoints: Feature<Point>[] = [];\n\t\t\tlet resultPolyLines: Feature<Point | LineString>[] = [];\n\n\t\t\tfor (const feature of reducedSquareBoxGrid.features) {\n\t\t\t\tconst tmpBbox = bbox(feature);\n\t\t\t\t// console.log(\"feature coordinates\", tmpBbox);\n\n\t\t\t\tconst { polyPoints, trapPoints: gridTraps } = await traps(\n\t\t\t\t\t{\n\t\t\t\t\t\tlng: tmpBbox[0],\n\t\t\t\t\t\tlat: tmpBbox[1],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlng: tmpBbox[2],\n\t\t\t\t\t\tlat: tmpBbox[3],\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (gridTraps.length > 499)\n\t\t\t\t\tconsole.log(\"gridTraps >>>\", gridTraps.length);\n\n\t\t\t\tresultTraps = resultTraps.concat(gridTraps);\n\t\t\t\tresultPolyPoints = resultPolyPoints.concat(polyPoints);\n\t\t\t}\n\n\t\t\t// console.log(\"resultPolyPoints\", resultPolyPoints.length);\n\t\t\t// console.log(\"resultTraps\", resultTraps.length);\n\t\t\t// console.log(\"resultTraps\", JSON.stringify(resultTraps, null, 4));\n\n\t\t\tresultTraps = pointsWithinPolygon(\n\t\t\t\tfeatureCollection(resultTraps),\n\t\t\t\tareaPolygon,\n\t\t\t).features;\n\n\t\t\tresultPolyPoints = pointsWithinPolygon(\n\t\t\t\tfeatureCollection(resultPolyPoints),\n\t\t\t\tareaPolygon,\n\t\t\t).features;\n\n\t\t\t/* console.log(\n\t\t\t\t\"resultPolyPoints after reduction\",\n\t\t\t\tresultPolyPoints.length,\n\t\t\t); */\n\n\t\t\t// console.log(\"resultTraps after reduction\", resultTraps.length);\n\n\t\t\tresultTraps = determineTrapTypes(resultTraps);\n\t\t\t// console.log(\"resultTraps\", JSON.stringify(resultTraps, null, 4));\n\n\t\t\tconst endTime = performance.now();\n\t\t\tconsole.log(\n\t\t\t\t`patchOrCreateArea() dauerte: ${\n\t\t\t\t\t(endTime - startTime) / 1_000\n\t\t\t\t} Sekunden`,\n\t\t\t);\n\n\t\t\tdata!.areaTraps = resultTraps;\n\n\t\t\t// console.log(\"resultPolyPoints\", resultPolyPoints);\n\n\t\t\tresultPolyLines = featureReduce(\n\t\t\t\tfeatureCollection(resultPolyPoints),\n\t\t\t\t(\n\t\t\t\t\tfeatures: Feature<Point | LineString, Properties>[],\n\t\t\t\t\ttmpFeature,\n\t\t\t\t) => {\n\t\t\t\t\tfeatures.push(tmpFeature);\n\t\t\t\t\tfeatures.push(\n\t\t\t\t\t\tfeature<LineString, Properties>(\n\t\t\t\t\t\t\tpolyline.toGeoJSON(\n\t\t\t\t\t\t\t\ttmpFeature.properties!.polyline as string,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t{ ...tmpFeature.properties! },\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\treturn features;\n\t\t\t\t},\n\t\t\t\t[],\n\t\t\t);\n\n\t\t\tdata!.polysFeatureCollection = featureCollection(resultPolyLines);\n\t\t}\n\n\t\tif (record !== undefined) {\n\t\t\tcontext.result = await service.patch(\n\t\t\t\t_id,\n\t\t\t\tdata as Partial<radarTrap.Area>,\n\t\t\t\t{\n\t\t\t\t\t...params,\n\t\t\t\t\tpublishEvent: false,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn context;\n\t\t}\n\n\t\treturn context;\n\t};\n};\n\nexport { patchOrCreateArea };\n"],
  "mappings": "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",
  "names": ["bbox", "square", "transformScale", "bboxPolygon", "area", "squareGrid", "feature", "booleanOverlap", "booleanContains", "console", "pointsWithinPolygon", "polyline"]
}
