{
  "version": 3,
  "sources": ["../../src/lib/getTrapsFromDirection.ts"],
  "sourcesContent": ["import polyline from \"@mapbox/polyline\";\nimport along from \"@turf/along\";\nimport destination from \"@turf/destination\";\nimport { feature } from \"@turf/helpers\";\nimport length from \"@turf/length\";\nimport pointToLineDistance from \"@turf/point-to-line-distance\";\nimport { uniqWith } from \"lodash\";\nimport { determineTrapTypes } from \"./atudo/determineTrapTypes\";\nimport { traps } from \"./atudo/traps\";\n\ntype GetTrapsFromAtude = { direction: string; maxTrapDistance: number };\n\nconst getTrapsFromDirection = async ({\n\tdirection,\n\tmaxTrapDistance,\n}: GetTrapsFromAtude): Promise<Record<string, GeoJSON.Feature<GeoJSON.Point>[]>> => {\n\tconst directionLine = feature<GeoJSON.LineString, GeoJSON.GeoJsonProperties>(polyline.toGeoJSON(direction));\n\n\tlet resultTraps: GeoJSON.Feature<GeoJSON.Point>[] = [];\n\tconst directionSteps = Math.trunc(length(directionLine) / 6);\n\n\t// Console.log('directionSteps', directionSteps);\n\n\tfor (let i = 0; i <= directionSteps; i++) {\n\t\tconst directionPoint = along(directionLine, i * 6, {\n\t\t\tunits: \"kilometers\",\n\t\t});\n\t\tconst minBox = destination(directionPoint, 4, -135, {\n\t\t\tunits: \"kilometers\",\n\t\t});\n\t\tconst maxBox = destination(directionPoint, 4, 45, {\n\t\t\tunits: \"kilometers\",\n\t\t});\n\n\t\tconst { trapPoints: clusterTraps } = await traps(\n\t\t\t{\n\t\t\t\tlng: minBox.geometry.coordinates[0],\n\t\t\t\tlat: minBox.geometry.coordinates[1],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlng: maxBox.geometry.coordinates[0],\n\t\t\t\tlat: maxBox.geometry.coordinates[1],\n\t\t\t},\n\t\t);\n\n\t\tif (clusterTraps.length > 499) console.log(\"clusterTraps >>>\", clusterTraps.length);\n\n\t\tresultTraps = [...resultTraps, ...clusterTraps];\n\t}\n\n\tresultTraps = uniqWith(resultTraps, (trapA, trapB) => trapA.properties!.content === trapB.properties!.content);\n\n\tresultTraps = resultTraps.reduce<GeoJSON.Feature<GeoJSON.Point>[]>((list, trapPoint) => {\n\t\tconst trapDistance = pointToLineDistance(trapPoint, directionLine, {\n\t\t\tunits: \"meters\",\n\t\t});\n\n\t\tif (trapDistance <= maxTrapDistance) {\n\t\t\t// console.log(\"Treffer->Distanz:\", trapDistance);\n\t\t\ttrapPoint.properties!.distance = trapDistance;\n\t\t\tlist.push(trapPoint);\n\t\t}\n\n\t\treturn list;\n\t}, []);\n\n\treturn determineTrapTypes(resultTraps);\n};\n\nexport { getTrapsFromDirection };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqB;AACrB,mBAAkB;AAClB,yBAAwB;AACxB,qBAAwB;AACxB,oBAAmB;AACnB,oCAAgC;AAChC,oBAAyB;AACzB,gCAAmC;AACnC,mBAAsB;AAItB,MAAM,wBAAwB,OAAO;AAAA,EACpC;AAAA,EACA;AACD,MAAoF;AACnF,QAAM,oBAAgB,wBAAuD,gBAAAA,QAAS,UAAU,SAAS,CAAC;AAE1G,MAAI,cAAgD,CAAC;AACrD,QAAM,iBAAiB,KAAK,UAAM,cAAAC,SAAO,aAAa,IAAI,CAAC;AAI3D,WAAS,IAAI,GAAG,KAAK,gBAAgB,KAAK;AACzC,UAAM,qBAAiB,aAAAC,SAAM,eAAe,IAAI,GAAG;AAAA,MAClD,OAAO;AAAA,IACR,CAAC;AACD,UAAM,aAAS,mBAAAC,SAAY,gBAAgB,GAAG,MAAM;AAAA,MACnD,OAAO;AAAA,IACR,CAAC;AACD,UAAM,aAAS,mBAAAA,SAAY,gBAAgB,GAAG,IAAI;AAAA,MACjD,OAAO;AAAA,IACR,CAAC;AAED,UAAM,EAAE,YAAY,aAAa,IAAI,UAAM;AAAA,MAC1C;AAAA,QACC,KAAK,OAAO,SAAS,YAAY;AAAA,QACjC,KAAK,OAAO,SAAS,YAAY;AAAA,MAClC;AAAA,MACA;AAAA,QACC,KAAK,OAAO,SAAS,YAAY;AAAA,QACjC,KAAK,OAAO,SAAS,YAAY;AAAA,MAClC;AAAA,IACD;AAEA,QAAI,aAAa,SAAS;AAAK,cAAQ,IAAI,oBAAoB,aAAa,MAAM;AAElF,kBAAc,CAAC,GAAG,aAAa,GAAG,YAAY;AAAA,EAC/C;AAEA,oBAAc,wBAAS,aAAa,CAAC,OAAO,UAAU,MAAM,WAAY,YAAY,MAAM,WAAY,OAAO;AAE7G,gBAAc,YAAY,OAAyC,CAAC,MAAM,cAAc;AACvF,UAAM,mBAAe,8BAAAC,SAAoB,WAAW,eAAe;AAAA,MAClE,OAAO;AAAA,IACR,CAAC;AAED,QAAI,gBAAgB,iBAAiB;AAEpC,gBAAU,WAAY,WAAW;AACjC,WAAK,KAAK,SAAS;AAAA,IACpB;AAEA,WAAO;AAAA,EACR,GAAG,CAAC,CAAC;AAEL,aAAO,8CAAmB,WAAW;AACtC;",
  "names": ["polyline", "length", "along", "destination", "pointToLineDistance"]
}
