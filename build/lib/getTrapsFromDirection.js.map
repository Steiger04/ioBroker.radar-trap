{
  "version": 3,
  "sources": ["../../src/lib/getTrapsFromDirection.ts"],
  "sourcesContent": ["import polyline from \"@mapbox/polyline\";\nimport along from \"@turf/along\";\nimport destination from \"@turf/destination\";\nimport { feature } from \"@turf/helpers\";\nimport length from \"@turf/length\";\nimport pointToLineDistance from \"@turf/point-to-line-distance\";\nimport { uniqWith } from \"lodash\";\nimport { determineTrapTypes } from \"./atudo/determineTrapTypes\";\nimport { traps } from \"./atudo/traps\";\n\ntype GetTrapsFromAtude = { direction: string; maxTrapDistance: number };\n\nconst getTrapsFromDirection = async ({\n\tdirection,\n\tmaxTrapDistance,\n}: GetTrapsFromAtude): Promise<\n\tRecord<string, GeoJSON.Feature<GeoJSON.Point>[]>\n> => {\n\tconst directionLine = feature<\n\t\tGeoJSON.LineString,\n\t\tGeoJSON.GeoJsonProperties\n\t>(polyline.toGeoJSON(direction));\n\n\tlet resultTraps: GeoJSON.Feature<GeoJSON.Point>[] = [];\n\tconst directionSteps = Math.trunc(length(directionLine) / 6);\n\n\t// Console.log('directionSteps', directionSteps);\n\n\tfor (let i = 0; i <= directionSteps; i++) {\n\t\tconst directionPoint = along(directionLine, i * 6, {\n\t\t\tunits: \"kilometers\",\n\t\t});\n\t\tconst minBox = destination(directionPoint, 4, -135, {\n\t\t\tunits: \"kilometers\",\n\t\t});\n\t\tconst maxBox = destination(directionPoint, 4, 45, {\n\t\t\tunits: \"kilometers\",\n\t\t});\n\n\t\tconst { trapPoints: clusterTraps } = await traps(\n\t\t\t{\n\t\t\t\tlng: minBox.geometry.coordinates[0],\n\t\t\t\tlat: minBox.geometry.coordinates[1],\n\t\t\t},\n\t\t\t{\n\t\t\t\tlng: maxBox.geometry.coordinates[0],\n\t\t\t\tlat: maxBox.geometry.coordinates[1],\n\t\t\t},\n\t\t);\n\n\t\tif (clusterTraps.length > 499)\n\t\t\tconsole.log(\"clusterTraps >>>\", clusterTraps.length);\n\n\t\tresultTraps = [...resultTraps, ...clusterTraps];\n\t}\n\n\tresultTraps = uniqWith(\n\t\tresultTraps,\n\t\t(trapA, trapB) =>\n\t\t\ttrapA.properties!.content === trapB.properties!.content,\n\t);\n\n\tresultTraps = resultTraps.reduce<GeoJSON.Feature<GeoJSON.Point>[]>(\n\t\t(list, trapPoint) => {\n\t\t\tconst trapDistance = pointToLineDistance(trapPoint, directionLine, {\n\t\t\t\tunits: \"meters\",\n\t\t\t});\n\n\t\t\tif (trapDistance <= maxTrapDistance) {\n\t\t\t\t// console.log(\"Treffer->Distanz:\", trapDistance);\n\t\t\t\ttrapPoint.properties!.distance = trapDistance;\n\t\t\t\tlist.push(trapPoint);\n\t\t\t}\n\n\t\t\treturn list;\n\t\t},\n\t\t[],\n\t);\n\n\treturn determineTrapTypes(resultTraps);\n};\n\nexport { getTrapsFromDirection };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAqB;AACrB,mBAAkB;AAClB,yBAAwB;AACxB,qBAAwB;AACxB,oBAAmB;AACnB,oCAAgC;AAChC,oBAAyB;AACzB,gCAAmC;AACnC,mBAAsB;AAItB,MAAM,wBAAwB,OAAO;AAAA,EACpC;AAAA,EACA;AACD,MAEK;AACJ,QAAM,oBAAgB,wBAGpB,gBAAAA,QAAS,UAAU,SAAS,CAAC;AAE/B,MAAI,cAAgD,CAAC;AACrD,QAAM,iBAAiB,KAAK,UAAM,cAAAC,SAAO,aAAa,IAAI,CAAC;AAI3D,WAAS,IAAI,GAAG,KAAK,gBAAgB,KAAK;AACzC,UAAM,qBAAiB,aAAAC,SAAM,eAAe,IAAI,GAAG;AAAA,MAClD,OAAO;AAAA,IACR,CAAC;AACD,UAAM,aAAS,mBAAAC,SAAY,gBAAgB,GAAG,MAAM;AAAA,MACnD,OAAO;AAAA,IACR,CAAC;AACD,UAAM,aAAS,mBAAAA,SAAY,gBAAgB,GAAG,IAAI;AAAA,MACjD,OAAO;AAAA,IACR,CAAC;AAED,UAAM,EAAE,YAAY,aAAa,IAAI,UAAM;AAAA,MAC1C;AAAA,QACC,KAAK,OAAO,SAAS,YAAY;AAAA,QACjC,KAAK,OAAO,SAAS,YAAY;AAAA,MAClC;AAAA,MACA;AAAA,QACC,KAAK,OAAO,SAAS,YAAY;AAAA,QACjC,KAAK,OAAO,SAAS,YAAY;AAAA,MAClC;AAAA,IACD;AAEA,QAAI,aAAa,SAAS;AACzB,cAAQ,IAAI,oBAAoB,aAAa,MAAM;AAEpD,kBAAc,CAAC,GAAG,aAAa,GAAG,YAAY;AAAA,EAC/C;AAEA,oBAAc;AAAA,IACb;AAAA,IACA,CAAC,OAAO,UACP,MAAM,WAAY,YAAY,MAAM,WAAY;AAAA,EAClD;AAEA,gBAAc,YAAY;AAAA,IACzB,CAAC,MAAM,cAAc;AACpB,YAAM,mBAAe,8BAAAC,SAAoB,WAAW,eAAe;AAAA,QAClE,OAAO;AAAA,MACR,CAAC;AAED,UAAI,gBAAgB,iBAAiB;AAEpC,kBAAU,WAAY,WAAW;AACjC,aAAK,KAAK,SAAS;AAAA,MACpB;AAEA,aAAO;AAAA,IACR;AAAA,IACA,CAAC;AAAA,EACF;AAEA,aAAO,8CAAmB,WAAW;AACtC;",
  "names": ["polyline", "length", "along", "destination", "pointToLineDistance"]
}
